# CS-230-J7537-Portfolio

Client: The Gaming Room
Project: Draw It or Lose It

The Gaming Room commissioned us to create a cross-platform implementation of their hit game, Draw It or Lose It.
The game would need to be distributed to many different systems, and overcome the obstacles of
deploying to different architectures.

I believe I did particularly well documenting and analyzing the different systems we would need to deploy to determine
the pros and cons of each system for both server and client deployment, as well as the necessary tools and code that would need
to be procured/written to successfully deploy Draw It or Lose It to a broader audience.

The process I found useful for working through a design document when developing code, was reading over it multiple times to get a general idea
of what the parts would need to do. Once that was completed, I would list out the individual parts by necessity, and develop them in that order. This 
provided a means for testing as I went along and ensuring proper working code for each milestone of the process. If I hit a point in development
where the code provided a different than expected result, then I would know which portion of the doc to revisit, or ask questions on.

If I could revisit a portion of the documents to revise, I would revisit the design constraints. I have learned far more about ways to overcome some of the 
constraints and believe I could find solutions that would reduce the restrictions and provide a much better end product.

How did I interpret the user's needs and implement them and why is it important to consider the user's needs when designing?
Ultimately, the end-user is what matters on a project like this. It's not the engineer or the designer that will have to use the software (generally).
If your customer base of end users does not find the experience useful, or it feels like it could be done better, chances are, they will move to a more enjoyable
experience. Providing a great user experience and fitting the code to meet their needs is much more likely to bring in return users. When it comes to hearing the user's needs,
I generally take myself out of the developer's shoes and think about the problem from the user's point of view. As developers, we generally have a much higher threshold of acceptable
UX (since we are more focused on the function than the form). Looking at the problem from the user's point of view gives me a way to think about how I would expect the UX to look and feel, and 
provides a means to forget about the functionality for a moment. Once I have a general understanding of the look and feel, then I can return to the engineering details of making the functionality 
do exactly as specified. This provides a product that both feels good to use and does exactly as advertised.

Approaching the designing of the software, for me, generally involves brainstorming on the different features and functionality needed.
This provides me with a way to determine the data structure/possible algorithms that could be used to implement the software. As I grow my toolkit of DSAs, I find myself
implementing more complex classes that are far more efficient in their implementation than I did a couple of years ago when I just winged it.
